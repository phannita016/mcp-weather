package engine

import (
	"context"
	"weather/client/dtos"

	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
	"github.com/openai/openai-go/packages/param"
	"github.com/openai/openai-go/shared"
)

// Anthropics config
const (
	ANTHROPIC_API_KEY = ""
	MODEL             = shared.ChatModelGPT4o
)

type OpenAIClient struct {
	client *openai.Client
	model  string
}

func NewOpenAIClient(apiKey, model string) *OpenAIClient {
	client := openai.NewClient(
		option.WithAPIKey(apiKey),
		option.WithHeader("Content-Type", "application/json"),
	)

	return &OpenAIClient{
		client: &client,
		model:  model,
	}
}

// OpenAiEngine sends the provided messages and tools to the OpenAI Chat Completion API.
func (c *OpenAIClient) OpenAiEngine(messages []dtos.Message, tools []dtos.Tool) (*openai.ChatCompletion, error) {
	ctx := context.Background()

	// Convert internal message format to OpenAI SDK message format
	openaiMessages := prepareCompletionMessage(messages)

	// Convert internal tools to OpenAI SDK tools format
	toolParams := convertCompletionToolParam(tools)

	// Call the OpenAI chat completion API
	resp, err := c.client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Model:     MODEL,
		Messages:  openaiMessages,
		Tools:     toolParams,
		MaxTokens: param.Opt[int64]{Value: 1000},
	})
	if err != nil {
		return nil, err
	}

	return resp, nil
}

/*
convertMessagesToOpenAI transforms internal message objects into
OpenAI's message parameter format suitable for the API.

Roles used in chat messages:

  - user:
    Represents the end-user who sends input or queries to the AI assistant.

  - assistant:
    Represents the AI assistant's responses or messages generated by the model.

  - tool:
    Represents messages coming from external tools or APIs that the assistant calls
    during the conversation to provide additional information or perform actions.

Example flow:
User (role: user) -> Assistant (role: assistant) -> Tool (role: tool) -> Assistant (role: assistant)
*/
func prepareCompletionMessage(messages []dtos.Message) []openai.ChatCompletionMessageParamUnion {
	var openaiMessages []openai.ChatCompletionMessageParamUnion
	for _, msg := range messages {
		switch msg.Role {
		case "user":
			// User message format
			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfUser: &openai.ChatCompletionUserMessageParam{
					Role: "user",
					Content: openai.ChatCompletionUserMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content.(string)},
					},
				},
			})

		case "assistant":
			// Assistant message format, including any tool calls it made
			var toolCalls []openai.ChatCompletionMessageToolCallParam
			for _, tc := range msg.ToolCalls {
				toolCalls = append(toolCalls, openai.ChatCompletionMessageToolCallParam{
					ID:   tc.ID,
					Type: tc.Type,
					Function: openai.ChatCompletionMessageToolCallFunctionParam{
						Name:      tc.Function.Name,
						Arguments: tc.Function.Arguments,
					},
				})
			}

			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfAssistant: &openai.ChatCompletionAssistantMessageParam{
					Role: "assistant",
					Content: openai.ChatCompletionAssistantMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content.(string)},
					},
					ToolCalls: toolCalls,
				},
			})

		case "tool":
			// Tool message format, includes the ToolCallID
			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfTool: &openai.ChatCompletionToolMessageParam{
					Role:       "tool",
					ToolCallID: msg.ToolCallID,
					Content: openai.ChatCompletionToolMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content.(string)},
					},
				},
			})
		}
	}

	return openaiMessages
}

// convertToolsToOpenAI converts internal tool definitions into
// OpenAI's tool parameter format to be sent with the request.
func convertCompletionToolParam(tools []dtos.Tool) []openai.ChatCompletionToolParam {
	var toolParams []openai.ChatCompletionToolParam
	for _, t := range tools {
		toolParams = append(toolParams, openai.ChatCompletionToolParam{
			Type: "function",
			Function: shared.FunctionDefinitionParam{
				Name:        t.Name,
				Description: param.Opt[string]{Value: t.Description},
				Parameters:  shared.FunctionParameters(t.InputSchema),
			},
		})
	}

	return toolParams
}

// extractToolCalls filters and returns only tool calls of type "function"
func (c *OpenAIClient) ExtractToolCalls(toolCalls []openai.ChatCompletionMessageToolCall) []openai.ChatCompletionMessageToolCall {
	var extracted []openai.ChatCompletionMessageToolCall
	for _, tc := range toolCalls {
		if tc.Type == "function" {
			extracted = append(extracted, openai.ChatCompletionMessageToolCall{
				ID: tc.ID,
				Function: openai.ChatCompletionMessageToolCallFunction{
					Name:      tc.Function.Name,
					Arguments: tc.Function.Arguments,
				},
			})
		}
	}
	return extracted
}
