package engine

import (
	"context"

	"github.com/openai/openai-go"
	"github.com/openai/openai-go/option"
	"github.com/openai/openai-go/packages/param"
	"github.com/openai/openai-go/shared"
)

// Anthropics config
const MODEL = shared.ChatModelGPT4oMini

type OpenAIClient struct {
	client *openai.Client
	model  string
}

func NewOpenAIClient(apiKey, model string) *OpenAIClient {
	client := openai.NewClient(
		option.WithAPIKey(apiKey),
		option.WithHeader("Content-Type", "application/json"),
	)

	return &OpenAIClient{
		client: &client,
		model:  model,
	}
}

// OpenAiEngine sends the provided messages and tools to the OpenAI Chat Completion API.
func (c *OpenAIClient) OpenAiEngine(messages []openai.ChatCompletionMessage, tools []openai.ChatCompletionToolParam) (*openai.ChatCompletion, error) {
	ctx := context.Background()

	// Convert internal message format to OpenAI SDK message format
	openaiMessages := prepareCompletionMessage(messages)

	// Call the OpenAI chat completion API
	resp, err := c.client.Chat.Completions.New(ctx, openai.ChatCompletionNewParams{
		Model:     MODEL,
		Messages:  openaiMessages,
		Tools:     tools,
		MaxTokens: param.Opt[int64]{Value: 1000},
	})
	if err != nil {
		return nil, err
	}

	return resp, nil
}

/*
convertMessagesToOpenAI transforms internal message objects into
OpenAI's message parameter format suitable for the API.

Roles used in chat messages:

  - user:
    Represents the end-user who sends input or queries to the AI assistant.

  - assistant:
    Represents the AI assistant's responses or messages generated by the model.

  - tool:
    Represents messages coming from external tools or APIs that the assistant calls
    during the conversation to provide additional information or perform actions.

Example flow:
User (role: user) -> Assistant (role: assistant) -> Tool (role: tool) -> Assistant (role: assistant)
*/
func prepareCompletionMessage(messages []openai.ChatCompletionMessage) []openai.ChatCompletionMessageParamUnion {
	var openaiMessages []openai.ChatCompletionMessageParamUnion
	for _, msg := range messages {
		switch msg.Role {
		case "user":
			// User message format
			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfUser: &openai.ChatCompletionUserMessageParam{
					Role: "user",
					Content: openai.ChatCompletionUserMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content},
					},
				},
			})

		case "assistant":
			// Assistant message format, including any tool calls it made
			var toolCalls []openai.ChatCompletionMessageToolCallParam
			for _, tc := range msg.ToolCalls {
				toolCalls = append(toolCalls, openai.ChatCompletionMessageToolCallParam{
					ID:   tc.ID,
					Type: tc.Type,
					Function: openai.ChatCompletionMessageToolCallFunctionParam{
						Name:      tc.Function.Name,
						Arguments: tc.Function.Arguments,
					},
				})
			}

			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfAssistant: &openai.ChatCompletionAssistantMessageParam{
					Role: "assistant",
					Content: openai.ChatCompletionAssistantMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content},
					},
					ToolCalls: toolCalls,
				},
			})

		case "tool":
			// Tool message format, includes the ToolCallID
			openaiMessages = append(openaiMessages, openai.ChatCompletionMessageParamUnion{
				OfTool: &openai.ChatCompletionToolMessageParam{
					Role:       "tool",
					ToolCallID: msg.ToolCalls[0].ID,
					Content: openai.ChatCompletionToolMessageParamContentUnion{
						OfString: param.Opt[string]{Value: msg.Content},
					},
				},
			})
		}
	}
	return openaiMessages
}
